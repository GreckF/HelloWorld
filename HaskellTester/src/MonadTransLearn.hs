module MonadTransLearn where


newtype Writer w a = Writer { runWriter :: (a, w) }

instance Functor (Writer w) where
  fmap f w = Writer $ (f (fst w'), snd w')
    where w' = runWriter w

instance Monoid w => Applicative (Writer w) where
  pure a = Writer (a, mempty)
  f <*> ma = Writer ((fst $ runWriter f) (fst $ runWriter ma), (snd $ runWriter f) `mappend` (snd $ runWriter ma))

instance Monoid w => Monad (Writer w) where
  return = pure
  ma >>= f = Writer (fst b, snd ma' <> snd b)
    where ma' = runWriter ma
          b   = runWriter $ f (fst ma')
-- IdentityT
newtype IdentityT m a= IdentityT{ runIdentity :: m a}

instance Functor m => Functor (IdentityT m) where
  fmap f idt = IdentityT $
    fmap f (runIdentity idt)

instance Applicative m => Applicative (IdentityT m) where
  pure a = IdentityT $ pure a
  mf <*> ma = IdentityT $ mf' <*> ma'
    where
      mf' = runIdentity mf
      ma' = runIdentity ma

-- ReaderT
newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }

instance Functor m => Functor (ReaderT r m) where
  fmap f rma = ReaderT $ \ r ->
    fmap f $ runReaderT rma r

instance Applicative m => Applicative (ReaderT r m) where
  pure a = ReaderT $ const $ pure a
  rmab <*> rma = ReaderT $ rmb
    where
      rmb r = mab <*> ma
        where mab = runReaderT rmab r
              ma = runReaderT rma r

instance Monad m => Monad (ReaderT r m) where
  return = pure
  rma >>= armb = ReaderT $ \ r ->
    let ma = runReaderT rma r
    in  ma >>= \ a -> runReaderT (armb a) r

class MonadTrans t where
  lift :: Monad m => m a -> t m a

instance MonadTrans (ReaderT r) where
  lift ma = ReaderT $ const $ ma



newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }

instance (Monoid w, Functor m) => Functor (WriterT w m) where
  fmap f (WriterT maw) = WriterT mbw
    where
      mbw = fmap (\(a, w) -> (f a, w)) maw 
      
instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
  pure a = WriterT $ pure (a, mempty)
  (WriterT mabw) <*> (WriterT maw) = WriterT $ mbw
    where 
      mbw = (\(ab, w) (a, w')-> (ab a, w <> w')) <$> mabw <*> maw
  
instance (Monoid w, Monad m) => Monad (WriterT w m) where
  return = pure
  WriterT maw >>= ambw = WriterT $ mbw
    where
      mbw = maw >>= \(a, w) -> runWriterT (ambw a) >>= \(b, w') -> return (b, w <> w')
  
  
  
newtype State s a = State { runState :: s -> (a, s) }

instance Functor (State s) where
  fmap f (State sa) = State sb
    where 
      sb s = (f a, s') where (a,s') = sa s
  
instance Applicative (State s) where
  pure a = State $ \s -> (a, s)
  State sab <*> State sa = State sb
    where 
      sb s = (ab a, s'')
        where 
          (ab, s') = sab s
          (a, s'') = sa s'
  
instance Monad (State s) where
  return = pure
  State sa >>= asb = State sb
    where
      sb s = runState (asb a) s'
        where
          (a, s') = sa s


























































































































































































































































































































































































































































































































































































































































































































































































































































