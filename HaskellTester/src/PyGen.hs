{-# LANGUAGE NoImplicitPrelude #-}
module PyGen where

-- import Control.Concurrent
-- import Control.Monad
-- import Data.Sequence.Internal
-- import qualified Data.Map as Map
-- import qualified Prelude as P
-- 
-- 
-- 
-- data Value = Str P.String
--            | Var P.String
--            | Int P.Integer
--            | Double P.Double
--            | Float P.Float
--            | (:+) Value Value
--            | (:-) Value Value
--            | (:*) Value Value
--            | (:/) Value Value
--            | (:**)Value Value
--            | True
--            | False
--            | (:&) Value Value
--            | (:|) Value Value
--            | Function Value Value
--            | DirectStr P.String
--   deriving P.Show
-- 
-- toStr :: Value -> P.String
-- toStr (Str s) = "\"" P.++ s P.++ "\""
-- toStr (Var v) = v
-- toStr (Int i) = P.show i
-- toStr (Double x) = P.show x
-- toStr (Float x) = P.show x
-- toStr (v :+ w) = toStr v P.++ " + " P.++ toStr w
-- toStr (v :- w) = toStr v P.++ " - " P.++ toStr w
-- toStr (v :* w) = toStr v P.++ " * " P.++ toStr w
-- toStr (v :/ w) = toStr v P.++ " / " P.++ toStr w
-- toStr (v :** w) = toStr v P.++ " ** " P.++ toStr w
-- toStr True = "True"
-- toStr False = "True"
-- toStr (v :& w) = toStr v P.++ " & " P.++ toStr w
-- toStr (v :| w) = toStr v P.++ " | " P.++ toStr w
-- toStr (Function v w) = toStr v P.++ " (" P.++ toStr w P.++ ") "
-- toStr (DirectStr s) = s
-- 
-- (+), (-), (*), (/), (**), (&&), (||), (#) :: Value -> Value -> Value
-- 
-- (+) = (:+)
-- (-) = (:-)
-- (*) = (:*)
-- (/) = (:/)
-- (**) = (:**)
-- (&&) = (:&)
-- (||) = (:|)
-- (#) = Function
-- 
-- infixl 6 :+
-- infixl 6 :-
-- infixl 7 :*
-- infixl 7 :/
-- infixl 8 :**
-- infixl 3 :&
-- infixl 2 :|
-- 
-- infixl 6 +
-- infixl 6 -
-- infixl 7 *
-- infixl 7 /
-- infixl 8 **
-- infixl 3 &&
-- infixl 2 ||
-- 
-- infixl 9 #
-- 
-- -- 用作状态
-- type Py = [P.String]
-- type PyMonad = State Py
-- 
-- ($) :: (a -> b) -> a -> b
-- f $ x = f x
-- infixr 0 $
-- 
-- start :: Py
-- start = []
-- 
-- 
-- addStatement :: Py -> P.String -> Py
-- addStatement py str = py P.++ [str]
-- 
-- print :: Value -> PyMonad ()
-- print v = State $ \py ->
--   (addStatement py ("print(" P.++ toStr v P.++ ")"), ())
-- 
-- (<<) :: Value -> Value -> PyMonad Value
-- (Var s) << v = State $ \py ->
--   (addStatement py (s P.++ " = " P.++ toStr v), v)
-- infixl 1 <<
-- 
-- tab :: P.String
-- tab = "\t"
-- 
-- addSubPy :: Py -> Py -> Py
-- addSubPy m s = m P.++ s'
--   where s' = P.map (\line -> tab P.++ line) s
-- 
-- 
-- for :: Value -> Value -> PyMonad () -> PyMonad ()
-- for (Var s) ls pym = State $ \py ->
--   (addSubPy (addStatement py $ join ["for ", s, " in ", toStr ls, ":"]) spy, ())
--   where
--     spy = P.fst $ runState pym start
-- 
-- if_ :: Value -> PyMonad () -> PyMonad ()
-- if_ b then_ = State $ \py ->
--   (addSubPy (addStatement py $ join ["if ", toStr b, ":"]) spy, ())
--   where
--     spy = P.fst $ runState then_ start
-- 
-- else_ :: PyMonad () -> PyMonad ()
-- else_ el = State $ \py ->
--   (addSubPy (addStatement py "else:") spy, ())
--   where
--    spy = P.fst $ runState el start
-- 
-- range :: Value -> Value -> Value
-- range s e = DirectStr $ join ["range(", (toStr s), ", ", (toStr e),")"]
-- 
-- list :: Value -> Value
-- list v = DirectStr $ join ["list(", toStr v, ")"]
-- 
-- input :: Value
-- input = DirectStr "input()"
-- 
-- 
-- 
-- 
-- 
-- 
-- test = do
--   print $ Str "Hello"
--   print $ Str "World"
--   Var "var1" << Int 1 + Int 10 * Double 15.8
--   Var "var2" << input
--   for (Var "i") {-in-} (range (Int 0) (Int 10)) $ do
--     print $ Var "i" + Var "var1"
--     print $ Var "var2"
-- 
-- 
-- 
-- 
-- sour = P.fst $ runState test start
-- 
-- output = do
--   forM_ sour $ \i -> do
--     P.putStrLn i
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 
-- 